#!/bin/python

nvdlav1_reg_list = []

nvdlav1_reg_list.append(("GLB.HW_VERSION",  "0x0000",	"HW version of NVDLA"))
nvdlav1_reg_list.append(("GLB.INTR_MASK",   "0x0004",	"Interrupt mask control"))
nvdlav1_reg_list.append(("GLB.INTR_SET",    "0x0008",	"Interrupt set control"))
nvdlav1_reg_list.append(("GLB.INTR_STATUS", "0x000c",	"Interrupt status"))

nvdlav1_reg_list.append(("MCIF.CFG_RD_WEIGHT_0",     "0x2000",	"Register0 to control the read weight of clients in MCIF"))
nvdlav1_reg_list.append(("MCIF.CFG_RD_WEIGHT_1",     "0x2004",	"Register1 to control the read weight of clients in MCIF"))
nvdlav1_reg_list.append(("MCIF.CFG_RD_WEIGHT_2",     "0x2008",	"Register2 to control the read weight of clients in MCIF"))
nvdlav1_reg_list.append(("MCIF.CFG_WR_WEIGHT_0",     "0x200c",	"Register0 to control the write weight of clients in MCIF"))
nvdlav1_reg_list.append(("MCIF.CFG_WR_WEIGHT_1",     "0x2010",	"Register1 to control the write weight of clients in MCIF"))
nvdlav1_reg_list.append(("MCIF.CFG_OUTSTANDING_CNT", "0x2014",	"Outstanding AXI transactions in unit of 64Byte"))
nvdlav1_reg_list.append(("MCIF.STATUS",              "0x2018",	"Idle status of MCIF"))

nvdlav1_reg_list.append(("SRAMIF.CFG_RD_WEIGHT_0",     "0x3000",	"Register0 to control the read weight of clients in MCIF"))
nvdlav1_reg_list.append(("SRAMIF.CFG_RD_WEIGHT_1",     "0x3004",	"Register1 to control the read weight of clients in MCIF"))
nvdlav1_reg_list.append(("SRAMIF.CFG_RD_WEIGHT_2",     "0x3008",	"Register2 to control the read weight of clients in MCIF"))
nvdlav1_reg_list.append(("SRAMIF.CFG_WR_WEIGHT_0",     "0x300c",	"Register0 to control the write weight of clients in MCIF"))
nvdlav1_reg_list.append(("SRAMIF.CFG_WR_WEIGHT_1",     "0x3010",	"Register1 to control the write weight of clients in MCIF"))
nvdlav1_reg_list.append(("SRAMIF.CFG_OUTSTANDING_CNT", "0x3014",	"Outstanding AXI transactions in unit of 64Byte"))
nvdlav1_reg_list.append(("SRAMIF.STATUS",              "0x3018",	"Idle status of SRAMIF"))

nvdlav1_reg_list.append(("BDMA.CFG_SRC_ADDR_LOW",        "0x4000",	"Lower 32bits of source address"))
nvdlav1_reg_list.append(("BDMA.CFG_SRC_ADDR_HIGH",       "0x4004",	"Higher 32bits of source address when axi araddr is 64bits"))
nvdlav1_reg_list.append(("BDMA.CFG_DST_ADDR_LOW",        "0x4008",	"Lower 32bits of dest address"))
nvdlav1_reg_list.append(("BDMA.CFG_DST_ADDR_HIGH",       "0x400c",	"Higher 32bits of dest address when axi awaddr is 64bits"))
nvdlav1_reg_list.append(("BDMA.CFG_LINE",                "0x4010",	"Size of one line"))
nvdlav1_reg_list.append(("BDMA.CFG_CMD",                 "0x4014",	"Ram type of source and destination"))
nvdlav1_reg_list.append(("BDMA.CFG_LINE_REPEAT",         "0x4018",	"Number of lines to be moved in one surface"))
nvdlav1_reg_list.append(("BDMA.CFG_SRC_LINE",            "0x401c",	"Source line stride"))
nvdlav1_reg_list.append(("BDMA.CFG_DST_LINE",            "0x4020",	"Destination line stride"))
nvdlav1_reg_list.append(("BDMA.CFG_SURF_REPEAT",         "0x4024",	"Number of surfaces to be moved in one operation"))
nvdlav1_reg_list.append(("BDMA.CFG_SRC_SURF",            "0x4028",	"Source surface stride"))
nvdlav1_reg_list.append(("BDMA.CFG_DST_SURF",            "0x402c",	"Destination surface stride"))
nvdlav1_reg_list.append(("BDMA.CFG_OP",                  "0x4030",	"This register is not used in NVDLA 1.0"))
nvdlav1_reg_list.append(("BDMA.CFG_LAUNCH0",             "0x4034",	"Set it to 1 to kick off operations in group0"))
nvdlav1_reg_list.append(("BDMA.CFG_LAUNCH1",             "0x4038",	"Set it to 1 to kick off operations in group1"))
nvdlav1_reg_list.append(("BDMA.CFG_STATUS",              "0x403c",	"Enable/Disable of counting stalls"))
nvdlav1_reg_list.append(("BDMA.STATUS",                  "0x4040",	"Status register: idle status of bdma, group0 and group1"))
nvdlav1_reg_list.append(("BDMA.STAUS_GRP0_READ_STALL",   "0x4044",	"Counting register of group0 read stall"))
nvdlav1_reg_list.append(("BDMA.STATUS_GRP0_WRITE_STALL", "0x4048",	"Counting register of group0 write stall"))
nvdlav1_reg_list.append(("BDMA.STAUS_GRP1_READ_STALL",   "0x404c",	"Counting register of group1 read stall"))
nvdlav1_reg_list.append(("BDMA.STATUS_GRP1_WRITE_STALL", "0x4050",	"Counting register of group1 write stall"))

nvdlav1_reg_list.append(("CDMA.S_STATUS",                "0x5000",	"Idle status of two register groups"))
nvdlav1_reg_list.append(("CDMA.S_POINTER",               "0x5004",	"Pointer for CSB master and data path to access groups"))
nvdlav1_reg_list.append(("CDMA.S_ARBITER",               "0x5008",  "WMB and Weight share same port to access external memory., This register controls the weight factor in the arbiter."))
nvdlav1_reg_list.append(("CDMA.S_CBUF_FLUSH_STATUS",     "0x500c",	"Indicates whether CBUF flush is finished after reset."))
nvdlav1_reg_list.append(("CDMA.D_OP_ENABLE",             "0x5010",	"Set it to 1 to kick off operation for current register group"))
nvdlav1_reg_list.append(("CDMA.D_MISC_CFG",              "0x5014",	"Configuration of operation: convolution mode, precision, weight reuse, data reuse."))
nvdlav1_reg_list.append(("CDMA.D_DATAIN_FORMAT",         "0x5018",	"Input data format and pixel format"))
nvdlav1_reg_list.append(("CDMA.D_DATAIN_SIZE_0",         "0x501c",	"Input cube’s width and height"))
nvdlav1_reg_list.append(("CDMA.D_DATAIN_SIZE_1",         "0x5020",	"Input cube’s channel"))
nvdlav1_reg_list.append(("CDMA.D_DATAIN_SIZE_EXT_0",     "0x5024",	"Input cube’s width and height after extension"))
nvdlav1_reg_list.append(("CDMA.D_PIXEL_OFFSET",          "0x5028",	"For image-in mode, horizontal offset and vertical offset of the 1 st pixel."))
nvdlav1_reg_list.append(("CDMA.D_DAIN_RAM_TYPE",         "0x502c",	"Ram type of input RAM"))
nvdlav1_reg_list.append(("CDMA.D_DAIN_ADDR_HIGH_0",      "0x5030",	"Higher 32bits of input data address when axi araddr is 64bits"))
nvdlav1_reg_list.append(("CDMA.D_DAIN_ADDR_LOW_0",       "0x5034",	"Lower 32bits of input data address"))
nvdlav1_reg_list.append(("CDMA.D_DAIN_ADDR_HIGH_1",      "0x5038",	"Higher 32bits of input data address of UV plane when axi araddr is 64bits"))
nvdlav1_reg_list.append(("CDMA.D_DAIN_ADDR_LOW_1",       "0x503c",	"Lower 32bits of input data address of UV plane"))
nvdlav1_reg_list.append(("CDMA.D_LINE_STRIDE",           "0x5040",	"Line stride of input cube"))
nvdlav1_reg_list.append(("CDMA.D_LINE_UV_STRIDE",        "0x5044",	"Line stride of input cube’s UV plane"))
nvdlav1_reg_list.append(("CDMA.D_SURF_STRIDE",           "0x5048",	"Surface stride of input cube"))
nvdlav1_reg_list.append(("CDMA.D_DAIN_MAP",              "0x504c",	"Whether input cube is line packed or surface packed"))
nvdlav1_reg_list.append(("CDMA.RESERVED",                "0x5050",	"This address is reserved"))
nvdlav1_reg_list.append(("CDMA.RESERVED",                "0x5054",	"This address is reserved"))
nvdlav1_reg_list.append(("CDMA.D_BATCH_NUMBER",          "0x5058",	"Number of batches"))
nvdlav1_reg_list.append(("CDMA.D_BATCH_STRIDE",          "0x505c",	"The stride of input data cubes when batches > 1"))
nvdlav1_reg_list.append(("CDMA.D_ENTRY_PER_SLICE",       "0x5060",	"Number of CBUF entries used for one input slice"))
nvdlav1_reg_list.append(("CDMA.D_FETCH_GRAIN",           "0x5064",	"Number of slices to be fetched before sending update information to CSC"))
nvdlav1_reg_list.append(("CDMA.D_WEIGHT_FORMAT",         "0x5068",	"Whether weight is compressed or not"))
nvdlav1_reg_list.append(("CDMA.D_WEIGHT_SIZE_0",         "0x506c",	"The size of one kernel in bytes"))
nvdlav1_reg_list.append(("CDMA.D_WEIGHT_SIZE_1",         "0x5070",	"Number of kernels"))
nvdlav1_reg_list.append(("CDMA.D_WEIGHT_RAM_TYPE",       "0x5074",	"Ram type of weight"))
nvdlav1_reg_list.append(("CDMA.D_WEIGHT_ADDR_HIGH",      "0x5078",	"Higher 32bits of weight address when axi araddr is 64bits"))
nvdlav1_reg_list.append(("CDMA.D_WEIGHT_ADDR_LOW",       "0x507c",	"Lower 32bits of weight address"))
nvdlav1_reg_list.append(("CDMA.D_WEIGHT_BYTES",          "0x5080",	"Total bytes of Weight"))
nvdlav1_reg_list.append(("CDMA.D_WGS_ADDR_HIGH",         "0x5084",	"Higher 32bits of wgs address when axi araddr is 64bits"))
nvdlav1_reg_list.append(("CDMA.D_WGS_ADDR_LOW",          "0x5088",	"Lower 32bits of wgs address"))
nvdlav1_reg_list.append(("CDMA.D_WMB_ADDR_HIGH",         "0x508c",	"Higher 32bits of wmb address when axi araddr is 64bits"))
nvdlav1_reg_list.append(("CDMA.D_WMB_ADDR_LOW",          "0x5090",	"Lower 32bits of wmb address"))
nvdlav1_reg_list.append(("CDMA.D_WMB_BYTES",             "0x5094",	"Total bytes of WMB"))
nvdlav1_reg_list.append(("CDMA.D_MEAN_FORMAT",           "0x5098",	"Whether mean registers are used or not"))
nvdlav1_reg_list.append(("CDMA.D_MEAN_GLOBAL_0",         "0x509c",  "Global mean value for red in RGB or Y in YUV, Global mean value for green in RGB or U in YUV"))
nvdlav1_reg_list.append(("CDMA.D_MEAN_GLOBAL_1",         "0x50a0",  "Global mean value for blue in RGB or V in YUV, Global mean value for alpha in ARGB/AYUV or X in XRGB"))
nvdlav1_reg_list.append(("CDMA.D_CVT_CFG",               "0x50a4",  "Enable/disable input data converter in CDMA and number of bits to be truncated in the input data converter"))
nvdlav1_reg_list.append(("CDMA.D_CVT_OFFSET",            "0x50a8",  "Offset of input data convertor"))
nvdlav1_reg_list.append(("CDMA.D_CVT_SCALE",             "0x50ac",  "Scale of input data convertor"))
nvdlav1_reg_list.append(("CDMA.D_CONV_STRIDE",           "0x50b0",  "Convolution x stride and convolution y stride"))
nvdlav1_reg_list.append(("CDMA.D_ZERO_PADDING",          "0x50b4",  "Left/right/top/bottom padding size"))
nvdlav1_reg_list.append(("CDMA.D_ZERO_PADDING_VALUE",    "0x50b8",  "Padding value"))
nvdlav1_reg_list.append(("CDMA.D_BANK",                  "0x50bc",  "Number of data banks and weight banks in CBUF"))
nvdlav1_reg_list.append(("CDMA.D_NAN_FLUSH_TO_ZERO",     "0x50c0",  "Enable/Disable flushing input NaN to zero"))
nvdlav1_reg_list.append(("CDMA.D_NAN_INPUT_DATA_NUM",    "0x50c4",  "Count NaN number in input data cube, update per layer"))
nvdlav1_reg_list.append(("CDMA.D_NAN_INPUT_WEIGHT_NUM",  "0x50c8",  "Count NaN number in weight kernels, update per layer"))
nvdlav1_reg_list.append(("CDMA.D_INF_INPUT_DATA_NUM",    "0x50cc",  "Count infinity number in input data cube, update per layer"))
nvdlav1_reg_list.append(("CDMA.D_INF_INPUT_WEIGHT_NUM",  "0x50d0",  "Count infinity number in weight kernels, update per layer"))
nvdlav1_reg_list.append(("CDMA.D_PERF_ENABLE",           "0x50d4",  "Enable/disable performance counter"))
nvdlav1_reg_list.append(("CDMA.D_PERF_DAT_READ_STALL",   "0x50d8",  "Count blocking cycles of read request of input data, update per layer"))
nvdlav1_reg_list.append(("CDMA.D_PERF_WT_READ_STALL",    "0x50dc",  "Count blocking cycles of read request of weight data, update per layer"))
nvdlav1_reg_list.append(("CDMA.D_PERF_DAT_READ_LATENCY", "0x50e0",  "Count total latency cycles of read response of input data, update per layer"))
nvdlav1_reg_list.append(("CDMA.D_PERF_WT_READ_LATENCY",  "0x50e4",  "Count total latency cycles of read request of weight data, update per layer"))

nvdlav1_reg_list.append(("CSC.S_STATUS",             "0x6000",      "Idle status of two register groups"))
nvdlav1_reg_list.append(("CSC.S_POINTER",            "0x6004",      "Pointer for CSB master and data path to access groups"))
nvdlav1_reg_list.append(("CSC.D_OP_ENABLE",          "0x6008",      "Set it to 1 to kick off operation for current register group"))
nvdlav1_reg_list.append(("CSC.D_MISC_CFG",           "0x600c",      "Configuration of operation: convolution mode, precision, weight reuse, data reuse."))
nvdlav1_reg_list.append(("CSC.D_DATAIN_FORMAT",      "0x6010",      "Input data format and pixel format"))
nvdlav1_reg_list.append(("CSC.D_DATAIN_SIZE_EXT_0",  "0x6014",      "Input cube’s width and height after extension"))
nvdlav1_reg_list.append(("CSC.D_DATAIN_SIZE_EXT_1",  "0x6018",      "Input cube’s channel after extension"))
nvdlav1_reg_list.append(("CSC.D_BATCH_NUMBER",       "0x601c",      "Number of batches"))
nvdlav1_reg_list.append(("CSC.D_POST_Y_EXTENSION",   "0x6020",      "Post extension parameter for image-in"))
nvdlav1_reg_list.append(("CSC.D_ENTRY_PER_SLICE",    "0x6024",      "Number of CBUF entries used for one input slice"))
nvdlav1_reg_list.append(("CSC.D_WEIGHT_FORMAT",      "0x6028",      "Whether weight is compressed or not"))
nvdlav1_reg_list.append(("CSC.D_WEIGHT_SIZE_EXT_0",  "0x602c",      "Weight’s width and height after extension"))
nvdlav1_reg_list.append(("CSC.D_WEIGHT_SIZE_EXT_1",  "0x6030",      "Weight’s channel after extension and number of weight kernels"))
nvdlav1_reg_list.append(("CSC.D_WEIGHT_BYTES",       "0x6034",      "Total bytes of Weight"))
nvdlav1_reg_list.append(("CSC.D_WMB_BYTES",          "0x6038",      "Total bytes of WMB"))
nvdlav1_reg_list.append(("CSC.D_DATAOUT_SIZE_0",     "0x603c",      "Output cube’s width and height"))
nvdlav1_reg_list.append(("CSC.D_DATAOUT_SIZE_1",     "0x6040",      "Output cube’s channel"))
nvdlav1_reg_list.append(("CSC.D_ATOMICS",            "0x6044",      "Equals to output_data_cube_width * output_data_cube_height - 1"))
nvdlav1_reg_list.append(("CSC.D_RELEASE",            "0x6048",      "Slices of CBUF to be released at the end of current layer"))
nvdlav1_reg_list.append(("CSC.D_CONV_STRIDE_EXT",    "0x604c",      "Convolution x stride and convolution y stride after extension"))
nvdlav1_reg_list.append(("CSC.D_DILATION_EXT",       "0x6050",      "Dilation parameter"))
nvdlav1_reg_list.append(("CSC.D_ZERO_PADDING",       "0x6054",      "Left/right/top/bottom padding size"))
nvdlav1_reg_list.append(("CSC.D_ZERO_PADDING_VALUE", "0x6058",      "Padding value"))
nvdlav1_reg_list.append(("CSC.D_BANK",               "0x605c",      "Number of data banks and weight banks in CBUF"))
nvdlav1_reg_list.append(("CSC.D_PRA_CFG",            "0x6060",      "PRA truncate in Winograd mode, range: 0~2"))

nvdlav1_reg_list.append(("CMAC_A.S_STATUS",    "0x7000",      "Idle status of two register groups"))
nvdlav1_reg_list.append(("CMAC_A.S_POINTER",   "0x7004",      "Pointer for CSB master and data path to access groups"))
nvdlav1_reg_list.append(("CMAC_A.D_OP_ENABLE", "0x7008",      "Set it to 1 to kick off operation for current register group"))
nvdlav1_reg_list.append(("CMAC_A.D_MISC_CFG",  "0x700c",      "Configuration of operation: convolution mode, precision, etc."))

nvdlav1_reg_list.append(("CMAC_B.S_STATUS",    "0x8000",      "Idle status of two register groups"))
nvdlav1_reg_list.append(("CMAC_B.S_POINTER",   "0x8004",      "Pointer for CSB master and data path to access groups"))
nvdlav1_reg_list.append(("CMAC_B.D_OP_ENABLE", "0x8008",      "Set it to 1 to kick off operation for current register group"))
nvdlav1_reg_list.append(("CMAC_B.D_MISC_CFG",  "0x800c",      "Configuration of operation: convolution mode, precision, etc."))

nvdlav1_reg_list.append(("CACC.S_STATUS",         "0x9000",      "Idle status of two register groups"))
nvdlav1_reg_list.append(("CACC.S_POINTER",        "0x9004",      "Pointer for CSB master and data path to access groups"))
nvdlav1_reg_list.append(("CACC.D_OP_ENABLE",      "0x9008",      "Set it to 1 to kick off operation for current register group"))
nvdlav1_reg_list.append(("CACC.D_MISC_CFG",       "0x900c",      "Configuration of operation: convolution mode, precision, etc."))
nvdlav1_reg_list.append(("CACC.D_DATAOUT_SIZE_0", "0x9010",      "Input cube’s width and height after extension"))
nvdlav1_reg_list.append(("CACC.D_DATAOUT_SIZE_1", "0x9014",      "Input cube’s channel after extension"))
nvdlav1_reg_list.append(("CACC.D_DATAOUT_ADDR",   "0x9018",      "Address of output cube"))
nvdlav1_reg_list.append(("CACC.D_BATCH_NUMBER",   "0x901c",      "Number of batches"))
nvdlav1_reg_list.append(("CACC.D_LINE_STRIDE",    "0x9020",      "Line stride of output cube"))
nvdlav1_reg_list.append(("CACC.D_SURF_STRIDE",    "0x9024",      "Line stride of surface cube"))
nvdlav1_reg_list.append(("CACC.D_DATAOUT_MAP",    "0x9028",      "Whether output cube is line packed or surface packed"))
nvdlav1_reg_list.append(("CACC.D_CLIP_CFG",       "0x902c",      "Number of bits to be truncated before sending to SDP"))
nvdlav1_reg_list.append(("CACC.D_OUT_SATURATION", "0x9030",      "Output saturation count"))

nvdlav1_reg_list.append(("SDP_RDMA.S_STATUS",                "0xa000",	"Idle status of two register groups"))
nvdlav1_reg_list.append(("SDP_RDMA.S_POINTER",               "0xa004",	"Pointer for CSB master and data path to access groups"))
nvdlav1_reg_list.append(("SDP_RDMA.D_OP_ENABLE",             "0xa008",	"Set it to 1 to kick off operation for current register group"))
nvdlav1_reg_list.append(("SDP_RDMA.D_DATA_CUBE_WIDTH",       "0xa00c",	"Input cube’s width"))
nvdlav1_reg_list.append(("SDP_RDMA.D_DATA_CUBE_HEIGHT",      "0xa010",	"Input cube’s height"))
nvdlav1_reg_list.append(("SDP_RDMA.D_DATA_CUBE_CHANNEL",     "0xa014",	"Input cube’s channel"))
nvdlav1_reg_list.append(("SDP_RDMA.D_SRC_BASE_ADDR_LOW",     "0xa018",	"Lower 32bits of input data address"))
nvdlav1_reg_list.append(("SDP_RDMA.D_SRC_BASE_ADDR_HIGH",    "0xa01c",	"Higher 32bits of input data address when axi araddr is 64bits"))
nvdlav1_reg_list.append(("SDP_RDMA.D_SRC_LINE_STRIDE",       "0xa020",	"Line stride of input cube"))
nvdlav1_reg_list.append(("SDP_RDMA.D_SRC_SURFACE_STRIDE",    "0xa024",	"Surface stride of input cube"))
nvdlav1_reg_list.append(("SDP_RDMA.D_BRDMA_CFG",             "0xa028",	"Configuration of BRDMA: enable/disable, data size, Ram type, etc."))
nvdlav1_reg_list.append(("SDP_RDMA.D_BS_BASE_ADDR_LOW",      "0xa02c",	"Lower 32bits address of the bias data cube"))
nvdlav1_reg_list.append(("SDP_RDMA.D_BS_BASE_ADDR_HIGH",     "0xa030",	"Higher 32bits address of the bias data cube when axi araddr is 64bits"))
nvdlav1_reg_list.append(("SDP_RDMA.D_BS_LINE_STRIDE",        "0xa034",	"Line stride of bias data cube"))
nvdlav1_reg_list.append(("SDP_RDMA.D_BS_SURFACE_STRIDE",     "0xa038",	"Surface stride of bias data cube"))
nvdlav1_reg_list.append(("SDP_RDMA.D_BS_BATCH_STRIDE",       "0xa03c",	"Stride of bias data cube in batch mode"))
nvdlav1_reg_list.append(("SDP_RDMA.D_NRDMA_CFG",             "0xa040",	"Configuration of NRDMA: enable/disable, data size, Ram type, etc."))
nvdlav1_reg_list.append(("SDP_RDMA.D_BN_BASE_ADDR_LOW",      "0xa044",	"Lower 32bits address of the bias data cube"))
nvdlav1_reg_list.append(("SDP_RDMA.D_BN_BASE_ADDR_HIGH",     "0xa048",	"Higher 32bits address of the bias data cube when axi araddr is 64bits"))
nvdlav1_reg_list.append(("SDP_RDMA.D_BN_LINE_STRIDE",        "0xa04c",	"Line stride of bias data cube"))
nvdlav1_reg_list.append(("SDP_RDMA.D_BN_SURFACE_STRIDE",     "0xa050",	"Surface stride of bias data cube"))
nvdlav1_reg_list.append(("SDP_RDMA.D_BN_BATCH_STRIDE",       "0xa054",	"Stride of bias data cube in batch mode"))
nvdlav1_reg_list.append(("SDP_RDMA.D_ERDMA_CFG",             "0xa058",	"Configuration of ERDMA: enable/disable, data size, Ram type, etc."))
nvdlav1_reg_list.append(("SDP_RDMA.D_EW_BASE_ADDR_LOW",      "0xa05c",	"Lower 32bits address of the bias data cube"))
nvdlav1_reg_list.append(("SDP_RDMA.D_EW_BASE_ADDR_HIGH",     "0xa060",	"Higher 32bits address of the bias data cube when axi araddr is 64bits"))
nvdlav1_reg_list.append(("SDP_RDMA.D_EW_LINE_STRIDE",        "0xa064",	"Line stride of bias data cube"))
nvdlav1_reg_list.append(("SDP_RDMA.D_EW_SURFACE_STRIDE",     "0xa068",	"Surface stride of bias data cube"))
nvdlav1_reg_list.append(("SDP_RDMA.D_EW_BATCH_STRIDE",       "0xa06c",	"Stride of bias data cube in batch mode"))
nvdlav1_reg_list.append(("SDP_RDMA.D_FEATURE_MODE_CFG",      "0xa070",	"Operation configuration: flying mode, output destination, Direct or Winograd mode, flush NaN to zero, batch number."))
nvdlav1_reg_list.append(("SDP_RDMA.D_SRC_DMA_CFG",           "0xa074",	"RAM type of input data cube"))
nvdlav1_reg_list.append(("SDP_RDMA.D_STATUS_NAN_INPUT_NUM",  "0xa078",	"Input NaN element number"))
nvdlav1_reg_list.append(("SDP_RDMA.D_STATUS_INF_INPUT_NUM",  "0xa07c",	"Input Infinity element number"))
nvdlav1_reg_list.append(("SDP_RDMA.D_PERF_ENABLE",           "0xa080",	"Enable/Disable performance counting"))
nvdlav1_reg_list.append(("SDP_RDMA.D_PERF_MRDMA_READ_STALL", "0xa084",	"Count stall cycles of M read DMA for one layer"))
nvdlav1_reg_list.append(("SDP_RDMA.D_PERF_BRDMA_READ_STALL", "0xa088",	"Count stall cycles of B read DMA for one layer"))
nvdlav1_reg_list.append(("SDP_RDMA.D_PERF_NRDMA_READ_STALL", "0xa08c",	"Count stall cycles of N read DMA for one layer"))
nvdlav1_reg_list.append(("SDP_RDMA.D_PERF_ERDMA_READ_STALL", "0xa090",	"Count stall cycles of E read DMA for one layer"))

nvdlav1_reg_list.append(("SDP.S_STATUS",                       "0xb000",	"Idle status of two register groups"))
nvdlav1_reg_list.append(("SDP.S_POINTER",                      "0xb004",	"Pointer for CSB master and data path to access groups"))
nvdlav1_reg_list.append(("SDP.S_LUT_ACCESS_CFG",               "0xb008",	"LUT access address and type"))
nvdlav1_reg_list.append(("SDP.S_LUT_ACCESS_DATA",              "0xb00c",	"Data register of read or write LUT"))
nvdlav1_reg_list.append(("SDP.S_LUT_CFG",                      "0xb010",	"LUT’s type: exponent or linear. And the selection between LE and LO tables."))
nvdlav1_reg_list.append(("SDP.S_LUT_INFO",                     "0xb014",	"LE and LO LUT index offset and selection"))
nvdlav1_reg_list.append(("SDP.S_LUT_LE_START",                 "0xb018",	"Start of LE LUT’s range"))
nvdlav1_reg_list.append(("SDP.S_LUT_LE_END",                   "0xb01c",	"End of LE LUT’s range"))
nvdlav1_reg_list.append(("SDP.S_LUT_LO_START",                 "0xb020",	"Start of LO LUT’s range"))
nvdlav1_reg_list.append(("SDP.S_LUT_LO_END",                   "0xb024",	"End of LO LUT’s range"))
nvdlav1_reg_list.append(("SDP.S_LUT_LE_SLOPE_SCALE",           "0xb028",	"Slope scale parameter for LE LUT underflow and overflow, signed value"))
nvdlav1_reg_list.append(("SDP.S_LUT_LE_SLOPE_SHIFT",           "0xb02c",	"Slope shift parameter for LE_LUT underflow and overflow, signed value"))
nvdlav1_reg_list.append(("SDP.S_LUT_LO_SLOPE_SCALE",           "0xb030",	"Slope scale parameter for LO LUT underflow and overflow, signed value"))
nvdlav1_reg_list.append(("SDP.S_LUT_LO_SLOPE_SHIFT",           "0xb034",	"Slope shift parameter for LO_LUT underflow and overflow, signed value"))
nvdlav1_reg_list.append(("SDP.D_OP_ENABLE",                    "0xb038",	"Set it to 1 to kick off operation for current register group"))
nvdlav1_reg_list.append(("SDP.D_DATA_CUBE_WIDTH",              "0xb03c",	"Input cube’s width"))
nvdlav1_reg_list.append(("SDP.D_DATA_CUBE_HEIGHT",             "0xb040",	"Input cube’s height"))
nvdlav1_reg_list.append(("SDP.D_DATA_CUBE_CHANNEL",            "0xb044",	"Input cube’s channel"))
nvdlav1_reg_list.append(("SDP.D_DST_BASE_ADDR_LOW",            "0xb048",	"Lower 32bits of output data address"))
nvdlav1_reg_list.append(("SDP.D_DST_BASE_ADDR_HIGH",           "0xb04c",	"Higher 32bits of output data address when axi awaddr is 64bits"))
nvdlav1_reg_list.append(("SDP.D_DST_LINE_STRIDE",              "0xb050",	"Line stride of output data cube"))
nvdlav1_reg_list.append(("SDP.D_DST_SURFACE_STRIDE",           "0xb054",	"Surface stride of output data cube"))
nvdlav1_reg_list.append(("SDP.D_DP_BS_CFG",                    "0xb058",	"Configurations of BS module: bypass, algorithm, etc."))
nvdlav1_reg_list.append(("SDP.D_DP_BS_ALU_CFG",                "0xb05c",	"Source type and shifter value of BS ALU"))
nvdlav1_reg_list.append(("SDP.D_DP_BS_ALU_SRC_VALUE",          "0xb060",	"Operand value of BS ALU"))
nvdlav1_reg_list.append(("SDP.D_DP_BS_MUL_CFG",                "0xb064",	"Source type and shifter value of BS MUL"))
nvdlav1_reg_list.append(("SDP.D_DP_BS_MUL_SRC_VALUE",          "0xb068",	"Operand value of BS MUL"))
nvdlav1_reg_list.append(("SDP.D_DP_BN_CFG",                    "0xb06c",	"Configurations of BN module: bypass, algorithm, etc."))
nvdlav1_reg_list.append(("SDP.D_DP_BN_ALU_CFG",                "0xb070",	"Source type and shifter value of BN ALU"))
nvdlav1_reg_list.append(("SDP.D_DP_BN_ALU_SRC_VALUE",          "0xb074",	"Operand value of BN ALU"))
nvdlav1_reg_list.append(("SDP.D_DP_BN_MUL_CFG",                "0xb078",	"Source type and shifter value of BN MUL"))
nvdlav1_reg_list.append(("SDP.D_DP_BN_MUL_SRC_VALUE",          "0xb07c",	"Operand value of BN MUL"))
nvdlav1_reg_list.append(("SDP.D_DP_EW_CFG",                    "0xb080",	"Configurations of EW module: bypass, algorithm, etc."))
nvdlav1_reg_list.append(("SDP.D_DP_EW_ALU_CFG",                "0xb084",	"Source type and bypass control of EW ALU"))
nvdlav1_reg_list.append(("SDP.D_DP_EW_ALU_SRC_VALUE",          "0xb088",	"Operand value of EW ALU"))
nvdlav1_reg_list.append(("SDP.D_DP_EW_ALU_CVT_OFFSET_VALUE",   "0xb08c",	"Converter offset of EW ALU"))
nvdlav1_reg_list.append(("SDP.D_DP_EW_ALU_CVT_SCALE_VALUE",    "0xb090",	"Converter scale of EW ALU"))
nvdlav1_reg_list.append(("SDP.D_DP_EW_ALU_CVT_TRUNCATE_VALUE", "0xb094",	"Converter truncate of EW ALU"))
nvdlav1_reg_list.append(("SDP.D_DP_EW_MUL_CFG",                "0xb098",	"Source type and bypass control of EW MUL"))
nvdlav1_reg_list.append(("SDP.D_DP_EW_MUL_SRC_VALUE",          "0xb09c",	"Operand value of EW MUL"))
nvdlav1_reg_list.append(("SDP.D_DP_EW_MUL_CVT_OFFSET_VALUE",   "0xb0a0",	"Converter offset of EW MUL"))
nvdlav1_reg_list.append(("SDP.D_DP_EW_MUL_CVT_SCALE_VALUE",    "0xb0a4",	"Converter scale of EW MUL"))
nvdlav1_reg_list.append(("SDP.D_DP_EW_MUL_CVT_TRUNCATE_VALUE", "0xb0a8",	"Converter truncate of EW MUL"))
nvdlav1_reg_list.append(("SDP.D_DP_EW_TRUNCATE_VALUE",         "0xb0ac",	"Truncate of EW"))
nvdlav1_reg_list.append(("SDP.D_FEATURE_MODE_CFG",             "0xb0b0",	"Operation configuration: flying mode, output destination, Direct or Winograd mode, flush NaN to zero, batch number."))
nvdlav1_reg_list.append(("SDP.D_DST_DMA_CFG",                  "0xb0b4",	"Destination RAM type"))
nvdlav1_reg_list.append(("SDP.D_DST_BATCH_STRIDE",             "0xb0b8",	"Stride of output cubes in batch mode"))
nvdlav1_reg_list.append(("SDP.D_DATA_FORMAT",                  "0xb0bc",	"Data precision"))
nvdlav1_reg_list.append(("SDP.D_CVT_OFFSET",                   "0xb0c0",	"Output converter offset"))
nvdlav1_reg_list.append(("SDP.D_CVT_SCALE",                    "0xb0c4",	"Output converter scale"))
nvdlav1_reg_list.append(("SDP.D_CVT_SHIFT",                    "0xb0c8",	"Output converter shifter value"))
nvdlav1_reg_list.append(("SDP.D_STATUS",                       "0xb0cc",	"Output of equal mode"))
nvdlav1_reg_list.append(("SDP.D_STATUS_NAN_INPUT_NUM",         "0xb0d0",	"Input NaN element number"))
nvdlav1_reg_list.append(("SDP.D_STATUS_INF_INPUT_NUM",         "0xb0d4",	"Input Infinity element number"))
nvdlav1_reg_list.append(("SDP.D_STATUS_NAN_OUTPUT_NUM",        "0xb0d8",	"Output NaN element number"))
nvdlav1_reg_list.append(("SDP.D_PERF_ENABLE",                  "0xb0dc",	"Enable/Disable performance counting"))
nvdlav1_reg_list.append(("SDP.D_PERF_WDMA_WRITE_STALL",        "0xb0e0",	"Count stall cycles of write DMA for one layer"))
nvdlav1_reg_list.append(("SDP.D_PERF_LUT_UFLOW",               "0xb0e4",	"Element number of both table underflow"))
nvdlav1_reg_list.append(("SDP.D_PERF_LUT_OFLOW",               "0xb0e8",	"Element number of both table overflow"))
nvdlav1_reg_list.append(("SDP.D_PERF_OUT_SATURATION",          "0xb0ec",	"Element number of both table saturation"))
nvdlav1_reg_list.append(("SDP.D_PERF_LUT_HYBRID",              "0xb0f0",	"Element number of both hit, or both miss situation that element underflow one table and at the same time overflow the other."))
nvdlav1_reg_list.append(("SDP.D_PERF_LUT_LE_HIT",              "0xb0f4",	"Element number of only LE table hit"))
nvdlav1_reg_list.append(("SDP.D_PERF_LUT_LO_HIT",              "0xb0f8",	"Element number of only LO table hit"))

nvdlav1_reg_list.append(("PDP_RDMA.S_STATUS",               "0xc000",	"Idle status of two register groups"))
nvdlav1_reg_list.append(("PDP_RDMA.S_POINTER",              "0xc004",	"Pointer for CSB master and data path to access groups"))
nvdlav1_reg_list.append(("PDP_RDMA.D_OP_ENABLE",            "0xc008",	"Set it to 1 to kick off operation for current register group"))
nvdlav1_reg_list.append(("PDP_RDMA.D_DATA_CUBE_IN_WIDTH",   "0xc00c",	"Input data cube’s width"))
nvdlav1_reg_list.append(("PDP_RDMA.D_DATA_CUBE_IN_HEIGHT",  "0xc010",	"Input data cube’s height"))
nvdlav1_reg_list.append(("PDP_RDMA.D_DATA_CUBE_IN_CHANNEL", "0xc014",	"Input data cube’s channel"))
nvdlav1_reg_list.append(("PDP_RDMA.D_FLYING_MODE",          "0xc018",	"Indicate source is SDP or external memory"))
nvdlav1_reg_list.append(("PDP_RDMA.D_SRC_BASE_ADDR_LOW",    "0xc01c",	"Lower 32bits of input data address"))
nvdlav1_reg_list.append(("PDP_RDMA.D_SRC_BASE_ADDR_HIGH",   "0xc020",	"Higher 32bits of input data address when axi araddr is 64bits"))
nvdlav1_reg_list.append(("PDP_RDMA.D_SRC_LINE_STRIDE",      "0xc024",	"Line stride of input cube"))
nvdlav1_reg_list.append(("PDP_RDMA.D_SRC_SURFACE_STRIDE",   "0xc028",	"Surface stride of input cube"))
nvdlav1_reg_list.append(("PDP_RDMA.D_SRC_RAM_CFG",          "0xc02c",	"RAM type of input data cube"))
nvdlav1_reg_list.append(("PDP_RDMA.D_DATA_FORMAT",          "0xc030",	"Input data cube"))
nvdlav1_reg_list.append(("PDP_RDMA.D_OPERATION_MODE_CFG",   "0xc034",	"Split number"))
nvdlav1_reg_list.append(("PDP_RDMA.D_POOLING_KERNEL_CFG",   "0xc038",	"Kernel width and kernel stride"))
nvdlav1_reg_list.append(("PDP_RDMA.D_POOLING_PADDING_CFG",  "0xc03c",	"Padding width"))
nvdlav1_reg_list.append(("PDP_RDMA.D_PARTIAL_WIDTH_IN",     "0xc040",	"Partial width for first, last and middle partitions"))
nvdlav1_reg_list.append(("PDP_RDMA.D_PERF_ENABLE",          "0xc044",	"Enable/Disable performance counting"))
nvdlav1_reg_list.append(("PDP_RDMA.D_PERF_READ_STALL",      "0xc048",	"Element number that for both LUT underflow."))

nvdlav1_reg_list.append(("PDP.S_STATUS",                      "0xd000",	"Idle status of two register groups"))
nvdlav1_reg_list.append(("PDP.S_POINTER",                     "0xd004",	"Pointer for CSB master and data path to access groups"))
nvdlav1_reg_list.append(("PDP.D_OP_ENABLE",                   "0xd008",	"Set it to 1 to kick off operation for current register group"))
nvdlav1_reg_list.append(("PDP.D_DATA_CUBE_IN_WIDTH",          "0xd00c",	"Input data cube’s width"))
nvdlav1_reg_list.append(("PDP.D_DATA_CUBE_IN_HEIGHT",         "0xd010",	"Input data cube’s height"))
nvdlav1_reg_list.append(("PDP.D_DATA_CUBE_IN_CHANNEL",        "0xd014",	"Input data cube’s channel"))
nvdlav1_reg_list.append(("PDP.D_DATA_CUBE_OUT_WIDTH",         "0xd018",	"Output data cube’s width"))
nvdlav1_reg_list.append(("PDP.D_DATA_CUBE_OUT_HEIGHT",        "0xd01c",	"Output data cube’s height"))
nvdlav1_reg_list.append(("PDP.D_DATA_CUBE_OUT_CHANNEL",       "0xd020",	"Output data cube’s channel"))
nvdlav1_reg_list.append(("PDP.D_OPERATION_MODE_CFG",          "0xd024",	"Split number"))
nvdlav1_reg_list.append(("PDP.D_NAN_FLUSH_TO_ZERO",           "0xd028",	"Option to flush input NaN to zero"))
nvdlav1_reg_list.append(("PDP.D_PARTIAL_WIDTH_IN",            "0xd02c",	"Partial width for first, last and middle partitions of input cube"))
nvdlav1_reg_list.append(("PDP.D_PARTIAL_WIDTH_OUT",           "0xd030",	"Partial width for first, last and middle partitions of output cube"))
nvdlav1_reg_list.append(("PDP.D_POOLING_KERNEL_CFG",          "0xd034",	"Kernel width and kernel stride"))
nvdlav1_reg_list.append(("PDP.D_RECIP_KERNEL_WIDTH",          "0xd038",	"Reciprocal of pooling kernel width, set to actual value * (2^16) when INT8/INT16 format enabled. and set to actual value for fp16 precision mode with fp17 data format."))
nvdlav1_reg_list.append(("PDP.D_RECIP_KERNEL_HEIGHT",         "0xd03c",	"Reciprocal of pooling kernel height, set to actual value * (2^16) when INT8/INT16 format enabled. and set to actual value for fp16 precision mode with fp17 data format."))
nvdlav1_reg_list.append(("PDP.D_POOLING_PADDING_CFG",         "0xd040",	"Left/right/top/bottom padding size"))
nvdlav1_reg_list.append(("PDP.D_POOLING_PADDING_VALUE_1_CFG", "0xd044",	"Padding_value*1"))
nvdlav1_reg_list.append(("PDP.D_POOLING_PADDING_VALUE_2_CFG", "0xd048",	"Padding_value*2"))
nvdlav1_reg_list.append(("PDP.D_POOLING_PADDING_VALUE_3_CFG", "0xd04c",	"Padding_value*3"))
nvdlav1_reg_list.append(("PDP.D_POOLING_PADDING_VALUE_4_CFG", "0xd050",	"Padding_value*4"))
nvdlav1_reg_list.append(("PDP.D_POOLING_PADDING_VALUE_5_CFG", "0xd054",	"Padding_value*5"))
nvdlav1_reg_list.append(("PDP.D_POOLING_PADDING_VALUE_6_CFG", "0xd058",	"Padding_value*6"))
nvdlav1_reg_list.append(("PDP.D_POOLING_PADDING_VALUE_7_CFG", "0xd05c",	"Padding_value*7"))
nvdlav1_reg_list.append(("PDP.D_SRC_BASE_ADDR_LOW",           "0xd060",	"Lower 32bits of input data address"))
nvdlav1_reg_list.append(("PDP.D_SRC_BASE_ADDR_HIGH",          "0xd064",	"Higher 32bits of input data address when axi araddr is 64bits"))
nvdlav1_reg_list.append(("PDP.D_SRC_LINE_STRIDE",             "0xd068",	"Line stride of input cube"))
nvdlav1_reg_list.append(("PDP.D_SRC_SURFACE_STRIDE",          "0xd06c",	"Surface stride of input cube"))
nvdlav1_reg_list.append(("PDP.D_DST_BASE_ADDR_LOW",           "0xd070",	"Lower 32bits of output data address"))
nvdlav1_reg_list.append(("PDP.D_DST_BASE_ADDR_HIGH",          "0xd074",	"Higher 32bits of output data address when axi awaddr is 64bits"))
nvdlav1_reg_list.append(("PDP.D_DST_LINE_STRIDE",             "0xd078",	"Line stride of output cube"))
nvdlav1_reg_list.append(("PDP.D_DST_SURFACE_STRIDE",          "0xd07c",	"Surface stride of output cube"))
nvdlav1_reg_list.append(("PDP.D_DST_RAM_CFG",                 "0xd080",	"RAM type of destination cube"))
nvdlav1_reg_list.append(("PDP.D_DATA_FORMAT",                 "0xd084",	"Precision of input data"))
nvdlav1_reg_list.append(("PDP.D_INF_INPUT_NUM",               "0xd088",	"Input infinity element number"))
nvdlav1_reg_list.append(("PDP.D_NAN_INPUT_NUM",               "0xd08c",	"Input NaN element number"))
nvdlav1_reg_list.append(("PDP.D_NAN_OUTPUT_NUM",              "0xd090",	"Output NaN element number"))
nvdlav1_reg_list.append(("PDP.D_PERF_ENABLE",                 "0xd094",	"Enable/disable performance counting"))
nvdlav1_reg_list.append(("PDP.D_PERF_WRITE_STALL",            "0xd098",	"Counting stalls of write requests"))

nvdlav1_reg_list.append(("CDP_RDMA.S_STATUS",             "0xe000",	"Idle status of two register groups"))
nvdlav1_reg_list.append(("CDP_RDMA.S_POINTER",            "0xe004",	"Pointer for CSB master and data path to access groups"))
nvdlav1_reg_list.append(("CDP_RDMA.D_OP_ENABLE",          "0xe008",	"Set it to 1 to kick off operation for current register group"))
nvdlav1_reg_list.append(("CDP_RDMA.D_DATA_CUBE_WIDTH",    "0xe00c",	"Input data cube’s width"))
nvdlav1_reg_list.append(("CDP_RDMA.D_DATA_CUBE_HEIGHT",   "0xe010",	"Input data cube’s height"))
nvdlav1_reg_list.append(("CDP_RDMA.D_DATA_CUBE_CHANNEL",  "0xe014",	"Input data cube’s channel"))
nvdlav1_reg_list.append(("CDP_RDMA.D_SRC_BASE_ADDR_LOW",  "0xe018",	"Lower 32bits of input data address"))
nvdlav1_reg_list.append(("CDP_RDMA.D_SRC_BASE_ADDR_HIGH", "0xe01c",	"Higher 32bits of input data address when axi araddr is 64bits"))
nvdlav1_reg_list.append(("CDP_RDMA.D_SRC_LINE_STRIDE",    "0xe020",	"Line stride of input cube"))
nvdlav1_reg_list.append(("CDP_RDMA.D_SRC_SURFACE_STRIDE", "0xe024",	"Surface stride of input cube"))
nvdlav1_reg_list.append(("CDP_RDMA.D_SRC_DMA_CFG",        "0xe028",	"RAM type of input data cube"))
nvdlav1_reg_list.append(("CDP_RDMA.D_SRC_COMPRESSION_EN", "0xe02c",	"This register is not used in OpenDLA 1.0"))
nvdlav1_reg_list.append(("CDP_RDMA.D_OPERATION_MODE",     "0xe030",	"Split number"))
nvdlav1_reg_list.append(("CDP_RDMA.D_DATA_FORMAT",        "0xe034",	"Input data cube"))
nvdlav1_reg_list.append(("CDP_RDMA.D_PERF_ENABLE",        "0xe038",	"Enable/Disable performance counting"))
nvdlav1_reg_list.append(("CDP_RDMA.D_PERF_READ_STALL",    "0xe03c",	"Counting stalls of read requests"))

nvdlav1_reg_list.append(("CDP.S_STATUS",             "0xf000",	"Idle status of two register groups"))
nvdlav1_reg_list.append(("CDP.S_POINTER",            "0xf004",	"Pointer for CSB master and data path to access groups"))
nvdlav1_reg_list.append(("CDP.S_LUT_ACCESS_CFG",     "0xf008",	"LUT access address and type"))
nvdlav1_reg_list.append(("CDP.S_LUT_ACCESS_DATA",    "0xf00c",	"Data register of read or write LUT"))
nvdlav1_reg_list.append(("CDP.S_LUT_CFG",            "0xf010",	"LUT’s type: exponent or linear. And the selection between LE and LO tables."))
nvdlav1_reg_list.append(("CDP.S_LUT_INFO",           "0xf014",	"LE and LO LUT index offset and selection"))
nvdlav1_reg_list.append(("CDP.S_LUT_LE_START_LOW",   "0xf018",	"Lower 32bits of start of LE LUT’s range"))
nvdlav1_reg_list.append(("CDP.S_LUT_LE_START_HIGH",  "0xf01c",	"Higher 6bits of start of LE LUT’s range"))
nvdlav1_reg_list.append(("CDP.S_LUT_LE_END_LOW",     "0xf020",	"Lower 32bits of end of LE LUT’s range"))
nvdlav1_reg_list.append(("CDP.S_LUT_LE_END_HIGH",    "0xf024",	"Higher 6bits of end of LE LUT’s range"))
nvdlav1_reg_list.append(("CDP.S_LUT_LO_START_LOW",   "0xf028",	"Lower 32bits of start of LO LUT’s range"))
nvdlav1_reg_list.append(("CDP.S_LUT_LO_START_HIGH",  "0xf02c",	"Higher 6bits of start of LO LUT’s range"))
nvdlav1_reg_list.append(("CDP.S_LUT_LO_END_LOW",     "0xf030",	"Lower 32bits of end of LO LUT’s range"))
nvdlav1_reg_list.append(("CDP.S_LUT_LO_END_HIGH",    "0xf034",	"Higher 6bits of end of LO LUT’s range"))
nvdlav1_reg_list.append(("CDP.S_LUT_LE_SLOPE_SCALE", "0xf038",	"Slope scale parameter for LE LUT underflow and overflow, signed value"))
nvdlav1_reg_list.append(("CDP.S_LUT_LE_SLOPE_SHIFT", "0xf03c",	"Slope shift parameter for LE_LUT underflow and overflow, signed value"))
nvdlav1_reg_list.append(("CDP.S_LUT_LO_SLOPE_SCALE", "0xf040",	"Slope scale parameter for LO LUT underflow and overflow, signed value"))
nvdlav1_reg_list.append(("CDP.S_LUT_LO_SLOPE_SHIFT", "0xf044",	"Slope shift parameter for LO_LUT underflow and overflow, signed value"))
nvdlav1_reg_list.append(("CDP.D_OP_ENABLE",          "0xf048",	"Set it to 1 to kick off operation for current register group"))
nvdlav1_reg_list.append(("CDP.D_FUNC_BYPASS",        "0xf04c",	"Square sum process bypass control and multiplier after interpolator bypass control"))
nvdlav1_reg_list.append(("CDP.D_DST_BASE_ADDR_LOW",  "0xf050",	"Lower 32bits of output data address"))
nvdlav1_reg_list.append(("CDP.D_DST_BASE_ADDR_HIGH", "0xf054",	"Higher 32bits of output data address when axi awaddr is 64bits"))
nvdlav1_reg_list.append(("CDP.D_DST_LINE_STRIDE",    "0xf058",	"Line stride of output cube"))
nvdlav1_reg_list.append(("CDP.D_DST_SURFACE_STRIDE", "0xf05c",	"Surface stride of output cube"))
nvdlav1_reg_list.append(("CDP.D_DST_DMA_CFG",        "0xf060",	"RAM type of output data cube"))
nvdlav1_reg_list.append(("CDP.D_DST_COMPRESSION_EN", "0xf064",	"This register is not used in OpenDLA 1.0"))
nvdlav1_reg_list.append(("CDP.D_DATA_FORMAT",        "0xf068",	"Precision of input data"))
nvdlav1_reg_list.append(("CDP.D_NAN_FLUSH_TO_ZERO",  "0xf06c",	"Option to flush input NaN to zero"))
nvdlav1_reg_list.append(("CDP.D_LRN_CFG",            "0xf070",	"Normalization length"))
nvdlav1_reg_list.append(("CDP.D_DATIN_OFFSET",       "0xf074",	"Input data convertor offset"))
nvdlav1_reg_list.append(("CDP.D_DATIN_SCALE",        "0xf078",	"Input data convertor scale"))
nvdlav1_reg_list.append(("CDP.D_DATIN_SHIFTER",      "0xf07c",	"Input data convertor shifter value"))
nvdlav1_reg_list.append(("CDP.D_DATOUT_OFFSET",      "0xf080",	"Output data convertor offset"))
nvdlav1_reg_list.append(("CDP.D_DATOUT_SCALE",       "0xf084",	"Output data convertor scale"))
nvdlav1_reg_list.append(("CDP.D_DATOUT_SHIFTER",     "0xf088",	"Output data convertor shifter value"))
nvdlav1_reg_list.append(("CDP.D_NAN_INPUT_NUM",      "0xf08c",	"input NaN element number"))
nvdlav1_reg_list.append(("CDP.D_INF_INPUT_NUM",      "0xf090",	"input Infinity element number"))
nvdlav1_reg_list.append(("CDP.D_NAN_OUTPUT_NUM",     "0xf094",	"output NaN element number"))
nvdlav1_reg_list.append(("CDP.D_OUT_SATURATION",     "0xf098",	"saturated element number."))
nvdlav1_reg_list.append(("CDP.D_PERF_ENABLE",        "0xf09c",	"Enable/Disable performance counting"))
nvdlav1_reg_list.append(("CDP.D_PERF_WRITE_STALL",   "0xf0a0",	"Element number that for both LUT under-flow"))
nvdlav1_reg_list.append(("CDP.D_PERF_LUT_UFLOW",     "0xf0a4",	"Element number that for both LUT under-flow"))
nvdlav1_reg_list.append(("CDP.D_PERF_LUT_OFLOW",     "0xf0a8",	"Element number that for both LUT over-flow"))
nvdlav1_reg_list.append(("CDP.D_PERF_LUT_HYBRID",    "0xf0ac",	"Element number that for both LUT miss, one is over-flow and the other is overflow"))
nvdlav1_reg_list.append(("CDP.D_PERF_LUT_LE_HIT",    "0xf0b0",	"Element number that for LE_lut hit only"))
nvdlav1_reg_list.append(("CDP.D_PERF_LUT_LO_HIT",    "0xf0b4",	"Element number that for LO_lut hit only"))

nvdlav1_reg_list.append(("RUBIK.S_STATUS",              "0x10000",	"Idle status of two register groups"))
nvdlav1_reg_list.append(("RUBIK.S_POINTER",             "0x10004",	"Pointer for CSB master and data path to access groups"))
nvdlav1_reg_list.append(("RUBIK.D_OP_ENABLE",           "0x10008",	"Set it to 1 to kick off operation for current register group"))
nvdlav1_reg_list.append(("RUBIK.D_MISC_CFG",            "0x1000c",	"Operation mode and precision"))
nvdlav1_reg_list.append(("RUBIK.D_DAIN_RAM_TYPE",       "0x10010",	"RAM type of input cube"))
nvdlav1_reg_list.append(("RUBIK.D_DATAIN_SIZE_0",       "0x10014",	"Input data cube’s width and height"))
nvdlav1_reg_list.append(("RUBIK.D_DATAIN_SIZE_1",       "0x10018",	"Input data cube’s channel"))
nvdlav1_reg_list.append(("RUBIK.D_DAIN_ADDR_HIGH",      "0x1001c",	"Higher 32bits of input data address when axi araddr is 64bits"))
nvdlav1_reg_list.append(("RUBIK.D_DAIN_ADDR_LOW",       "0x10020",	"Lower 32bits of input data address"))
nvdlav1_reg_list.append(("RUBIK.D_DAIN_LINE_STRIDE",    "0x10024",	"Line stride of input data cube"))
nvdlav1_reg_list.append(("RUBIK.D_DAIN_SURF_STRIDE",    "0x10028",	"Surface stride of input data cube"))
nvdlav1_reg_list.append(("RUBIK.D_DAIN_PLANAR_STRIDE",  "0x1002c",	"Input data planar stride, for merge mode only"))
nvdlav1_reg_list.append(("RUBIK.D_DAOUT_RAM_TYPE",      "0x10030",	"RAM type of output cube"))
nvdlav1_reg_list.append(("RUBIK.D_DATAOUT_SIZE_1",      "0x10034",	"Output data cube’s channel"))
nvdlav1_reg_list.append(("RUBIK.D_DAOUT_ADDR_HIGH",     "0x10038",	"Higher 32bits of output data address when axi awaddr is 64bits"))
nvdlav1_reg_list.append(("RUBIK.D_DAOUT_ADDR_LOW",      "0x1003c",	"Lower 32bits of output data address"))
nvdlav1_reg_list.append(("RUBIK.D_DAOUT_LINE_STRIDE",   "0x10040",	"Line stride of output data cube"))
nvdlav1_reg_list.append(("RUBIK.D_CONTRACT_STRIDE_0",   "0x10044",  "Input stride for each X step. Equals to (DATAOUT_CHANNEL+1) * BPE / 32 * DAIN_SURF_STRIDE,(BPE = (IN_PRECISION == INT8) ? 1 : 2;)"))
nvdlav1_reg_list.append(("RUBIK.D_CONTRACT_STRIDE_1",   "0x10048",  "Output stride corresponding to each line in input cube., equals to (DECONV_Y_STRIDE+1) * DAOUT_LINE_STRIDE"))
nvdlav1_reg_list.append(("RUBIK.D_DAOUT_SURF_STRIDE",   "0x1004c",	"Surface stride of output data cube"))
nvdlav1_reg_list.append(("RUBIK.D_DAOUT_PLANAR_STRIDE", "0x10050",	"Output data planar stride, for split mode only"))
nvdlav1_reg_list.append(("RUBIK.D_DECONV_STRIDE",       "0x10054",	"Deconvolution x stride and y stride"))
nvdlav1_reg_list.append(("RUBIK.D_PERF_ENABLE",         "0x10058",	"Enable/Disable performance counting"))
nvdlav1_reg_list.append(("RUBIK.D_PERF_READ_STALL",     "0x1005c",	"RD_STALL Count stall cycles of read DMA for one layer"))
nvdlav1_reg_list.append(("RUBIK.D_PERF_WRITE_STALL",    "0x10060",	"WR_STALL Count stall cycles of write DMA for one layer"))

def name_reglist(addr):
    for reg in nvdlav1_reg_list:
        if int(reg[1], 16) == addr:
            return reg[0]
    return 0
